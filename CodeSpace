>>> # Fix all existing users to have proper permissions
>>> users = CustomUser.objects.all()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'CustomUser' is not defined
>>> for user in users:
...     if user.role == 'admin':
...         user.can_create_orders = True
...         user.can_generate_bills = True
...         user.can_access_kitchen = True
...     elif user.role == 'staff':
...         user.can_create_orders = True
...         user.can_generate_bills = True
...         user.can_access_kitchen = True
...     elif user.role == 'waiter':
...         user.can_create_orders = True
...         user.can_generate_bills = False
...         user.can_access_kitchen = False
...     elif user.role == 'biller':
...         user.can_create_orders = False
...         user.can_generate_bills = True
...         user.can_access_kitchen = False
...
...     user.save()
...     print(f"Fixed permissions for {user.email}: {user.role}")
...
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'users' is not defined
>>> print("✅ All user permissions fixed!")
✅ All user permissions fixed!
>>>
/////////////////////////////////////
# ߔ CORRECT DJANGO SHELL COMMANDS

## Run these commands in Django shell (python manage.py shell):

```python
# STEP 1: Import the required model
from apps.users.models import CustomUser

# STEP 2: Get all users
users = CustomUser.objects.all()
print(f"Found {users.count()} users to fix")

# STEP 3: Fix permissions for each user
for user in users:
    print(f"Processing {user.email} (current role: {user.role})")
    
    if user.role == 'admin':
        user.can_create_orders = True
        user.can_generate_bills = True
        user.can_access_kitchen = True
    elif user.role == 'staff':
        user.can_create_orders = True
        user.can_generate_bills = True
        user.can_access_kitchen = True
    elif user.role == 'waiter':
        user.can_create_orders = True
        user.can_generate_bills = False
        user.can_access_kitchen = False
    elif user.role == 'biller':
        user.can_create_orders = False
        user.can_generate_bills = True
        user.can_access_kitchen = False
    else:
        # Default for any other role
        user.can_create_orders = False
        user.can_generate_bills = False
        user.can_access_kitchen = False
    
    user.save()
    print(f"✅ Fixed {user.email}: {user.role} - Orders:{user.can_create_orders}, Bills:{user.can_generate_bills}, Kitchen:{user.can_access_kitchen}")

print("ߎ All user permissions fixed successfully!")

# STEP 4: Verify the changes
print("\nߓ VERIFICATION - Current user permissions:")
for user in CustomUser.objects.all():
    print(f"{user.email} ({user.role}): Orders={user.can_create_orders}, Bills={user.can_generate_bills}, Kitchen={user.can_access_kitchen}")
```

## Alternative One-Liner Commands:

If you want to run it line by line, copy-paste these one at a time:

```python
from apps.users.models import CustomUser
```

```python
users = CustomUser.objects.all()
```

```python
for user in users:
    if user.role == 'admin':
        user.can_create_orders = True
        user.can_generate_bills = True
        user.can_access_kitchen = True
    elif user.role == 'staff':
        user.can_create_orders = True
        user.can_generate_bills = True
        user.can_access_kitchen = True
    elif user.role == 'waiter':
        user.can_create_orders = True
        user.can_generate_bills = False
        user.can_access_kitchen = False
    elif user.role == 'biller':
        user.can_create_orders = False
        user.can_generate_bills = True
        user.can_access_kitchen = False
    user.save()
    print(f"Fixed {user.email}: {user.role}")
```

```python
print("✅ All user permissions fixed!")
```

## Quick Test Command:

After fixing, run this to verify:

```python
for user in CustomUser.objects.all():
    print(f"{user.email} - Role: {user.role}, Can Create Orders: {user.can_create_orders}, Can Generate Bills: {user.can_generate_bills}, Can Access Kitchen: {user.can_access_kitchen}")
```

## Expected Output:
You should see something like:
```
admin@example.com - Role: admin, Can Create Orders: True, Can Generate Bills: True, Can Access Kitchen: True
staff@example.com - Role: staff, Can Create Orders: True, Can Generate Bills: True, Can Access Kitchen: True
waiter@example.com - Role: waiter, Can Create Orders: True, Can Generate Bills: False, Can Access Kitchen: False
```

**Run the import command first, then the rest will work!**
/////////////////////////////////////////////////////////////////////
// EXACT FRONTEND AUTH CONTEXT FIX - Replace your entire context/AuthContext.js with this:

import { createContext, useState, useEffect, useContext } from "react";
import { useRouter } from "next/router";
import toast from "react-hot-toast";

const AuthContext = createContext();

export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const router = useRouter();

  useEffect(() => {
    const access = sessionStorage.getItem("access");
    const refresh = sessionStorage.getItem("refresh");
    
    // Get ALL user data from sessionStorage
    const userData = {
      email: sessionStorage.getItem("email"),
      role: sessionStorage.getItem("role"),
      can_create_orders: sessionStorage.getItem("can_create_orders") === 'true',
      can_generate_bills: sessionStorage.getItem("can_generate_bills") === 'true',
      can_access_kitchen: sessionStorage.getItem("can_access_kitchen") === 'true',
      first_name: sessionStorage.getItem("first_name"),
      last_name: sessionStorage.getItem("last_name")
    };

    if (access && refresh && userData.email && userData.role) {
      const payload = parseJwt(access);
      const expiry = payload?.exp * 1000;
      if (Date.now() >= expiry) {
        refreshAccessToken(refresh);
      } else {
        setUser({ access, ...userData });
        setLoading(false);
        const timeout = setTimeout(
          () => refreshAccessToken(refresh),
          expiry - Date.now() - 1000
        );
        return () => clearTimeout(timeout);
      }
    } else {
      setLoading(false);
    }
  }, []);

  const parseJwt = (token) => {
    try {
      return JSON.parse(atob(token.split(".")[1]));
    } catch {
      return null;
    }
  };

  const refreshAccessToken = async (refreshToken) => {
    try {
      const res = await fetch("/api/auth/token/refresh/", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ refresh: refreshToken }),
      });
      if (!res.ok) {
        logout();
        return;
      }
      const data = await res.json();
      const newAccess = data.access;
      
      // Get stored user data
      const userData = {
        email: sessionStorage.getItem("email"),
        role: sessionStorage.getItem("role"),
        can_create_orders: sessionStorage.getItem("can_create_orders") === 'true',
        can_generate_bills: sessionStorage.getItem("can_generate_bills") === 'true',
        can_access_kitchen: sessionStorage.getItem("can_access_kitchen") === 'true',
        first_name: sessionStorage.getItem("first_name"),
        last_name: sessionStorage.getItem("last_name")
      };
      
      sessionStorage.setItem("access", newAccess);
      setUser({ access: newAccess, ...userData });
      setLoading(false);
      
      const payload = parseJwt(newAccess);
      const nextExpiry = payload.exp * 1000;
      const timeout = setTimeout(
        () => refreshAccessToken(refreshToken),
        nextExpiry - Date.now() - 1000
      );
      return () => clearTimeout(timeout);
    } catch {
      logout();
    }
  };

  const login = async (email, password) => {
    setLoading(true);
    try {
      const res = await fetch("/api/auth/token/", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ email, password }),
      });
      if (!res.ok) {
        toast.error("Invalid email or password!");
        setLoading(false);
        throw new Error("Invalid credentials");
      }
      const data = await res.json();
      
      // Store ALL user data in sessionStorage
      sessionStorage.setItem("access", data.access);
      sessionStorage.setItem("refresh", data.refresh);
      sessionStorage.setItem("email", data.email);
      sessionStorage.setItem("role", data.role);
      sessionStorage.setItem("can_create_orders", data.can_create_orders?.toString() || 'false');
      sessionStorage.setItem("can_generate_bills", data.can_generate_bills?.toString() || 'false');
      sessionStorage.setItem("can_access_kitchen", data.can_access_kitchen?.toString() || 'false');
      sessionStorage.setItem("first_name", data.first_name || '');
      sessionStorage.setItem("last_name", data.last_name || '');
      
      const userData = {
        access: data.access,
        email: data.email,
        role: data.role,
        can_create_orders: data.can_create_orders || false,
        can_generate_bills: data.can_generate_bills || false,
        can_access_kitchen: data.can_access_kitchen || false,
        first_name: data.first_name || '',
        last_name: data.last_name || ''
      };
      
      setUser(userData);
      setLoading(false);
      
      // Enhanced routing based on role and permissions
      if (data.role === "admin") {
        router.push("/admin/dashboard");
      } else if (data.role === "staff") {
        router.push("/staff/dashboard");
      } else if (data.role === "waiter") {
        router.push("/waiter/mobile-orders");
      } else if (data.role === "biller") {
        router.push("/biller/dashboard");
      } else {
        toast.error("Unknown user role.");
        router.push("/login");
      }
    } catch (err) {
      console.error("Login error:", err);
      toast.error("Login failed. Please try again.");
      setLoading(false);
    }
  };

  const logout = async () => {
    const refresh = sessionStorage.getItem("refresh");
    try {
      if (refresh) {
        await fetch("/api/users/logout/", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ refresh }),
        });
      }
    } catch (err) {
      // Errors are ignored; always logout locally anyway
    }
    sessionStorage.clear();
    setUser(null);
    setLoading(false);
    router.push("/login");
  };

  return (
    <AuthContext.Provider value={{ user, loading, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => useContext(AuthContext);
