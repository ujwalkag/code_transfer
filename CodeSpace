# EXACT CHANGES TO apps/users/models.py
class CustomUser(AbstractBaseUser, PermissionsMixin):
    ROLE_CHOICES = (
        ('admin', 'Admin'),
        ('staff', 'Staff'),
        ('waiter', 'Waiter'),        # ADD THIS
        ('biller', 'Biller'),        # ADD THIS
    )

    email = models.EmailField(unique=True)
    role = models.CharField(max_length=10, choices=ROLE_CHOICES)  # INCREASE to max_length=10
    is_active = models.BooleanField(default=True)
    is_staff = models.BooleanField(default=False)
    
    # ADD THESE PERMISSION FIELDS
    can_create_orders = models.BooleanField(default=False)
    can_generate_bills = models.BooleanField(default=False)
    can_access_kitchen = models.BooleanField(default=False)

    USERNAME_FIELD = 'email'
    REQUIRED_FIELDS = []
    objects = CustomUserManager()

    def __str__(self):
        return self.email
/////////////////////////


# ADD to existing UserSerializer
class UserSerializer(serializers.ModelSerializer):
    class Meta:
        model = CustomUser
        fields = ['id', 'email', 'role', 'can_create_orders', 'can_generate_bills', 'can_access_kitchen']

# ADD new serializer for admin role management
class UserRoleUpdateSerializer(serializers.ModelSerializer):
    class Meta:
        model = CustomUser
        fields = ['role', 'can_create_orders', 'can_generate_bills', 'can_access_kitchen']


////////////////////////////////////


# REPLACE EXISTING with enhanced permissions
class CanCreateOrders(BasePermission):
    """Permission for creating orders - waiters and admins"""
    def has_permission(self, request, view):
        return (
            request.user.is_authenticated and 
            (request.user.role == 'admin' or 
             (request.user.role == 'waiter' and request.user.can_create_orders))
        )

class CanGenerateBills(BasePermission):
    """Permission for generating bills - billers and admins"""
    def has_permission(self, request, view):
        return (
            request.user.is_authenticated and 
            (request.user.role == 'admin' or 
             (request.user.role == 'biller' and request.user.can_generate_bills))
        )

class CanAccessKitchen(BasePermission):
    """Permission for kitchen display access"""
    def has_permission(self, request, view):
        return (
            request.user.is_authenticated and 
            (request.user.role == 'admin' or request.user.can_access_kitchen)
        )


///////////////////////////////////////////////


# ADD these methods to TableOrderViewSet class
@action(detail=False, methods=['get'], permission_classes=[CanAccessKitchen])
def kitchen_display_live(self, request):
    """Real-time kitchen display data"""
    kitchen_items = KitchenDisplayItem.objects.filter(
        order_item__status__in=['pending', 'preparing']
    ).select_related(
        'order_item__table_order__table',
        'order_item__menu_item'
    ).order_by('-is_priority', 'display_time')
    
    serializer = KitchenDisplaySerializer(kitchen_items, many=True)
    return Response(serializer.data)

@action(detail=False, methods=['get'], permission_classes=[CanGenerateBills])
def biller_dashboard(self, request):
    """Get orders ready for billing grouped by table"""
    orders = TableOrder.objects.filter(
        status__in=['completed']
    ).select_related('table').prefetch_related('items')
    
    # Group by table
    orders_by_table = {}
    for order in orders:
        table_num = order.table.table_number
        if table_num not in orders_by_table:
            orders_by_table[table_num] = {
                'table': RestaurantTableSerializer(order.table).data,
                'orders': []
            }
        orders_by_table[table_num]['orders'].append(
            TableOrderSerializer(order).data
        )
    
    return Response(orders_by_table)

@action(detail=False, methods=['get'], permission_classes=[CanCreateOrders])
def waiter_orders(self, request):
    """Get orders for current waiter"""
    if request.user.role == 'waiter':
        orders = TableOrder.objects.filter(waiter=request.user)
    else:  # admin
        orders = TableOrder.objects.all()
    
    orders = orders.filter(
        status__in=['pending', 'in_progress', 'completed']
    ).order_by('-created_at')
    
    serializer = TableOrderSerializer(orders, many=True)
    return Response(serializer.data)

//////////////////////////////////


# ADD this method to StaffUserViewSet
@action(detail=True, methods=['patch'])
def update_permissions(self, request, pk=None):
    """Update user role and permissions"""
    try:
        user = CustomUser.objects.get(id=pk)
        if user.role == 'admin':
            return Response({'error': 'Cannot modify admin permissions'}, 
                          status=status.HTTP_400_BAD_REQUEST)
        
        serializer = UserRoleUpdateSerializer(user, data=request.data, partial=True)
        if serializer.is_valid():
            serializer.save()
            return Response({
                'message': 'Permissions updated successfully',
                'user': UserSerializer(user).data
            })
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        
    except CustomUser.DoesNotExist:
        return Response({'error': 'User not found'}, 
                       status=status.HTTP_404_NOT_FOUND)

///////////////////////////////////


// ENHANCED VERSION with permission checks
const withRoleGuard = (Component, allowedRoles, requiredPermissions = []) => {
  const allowed = Array.isArray(allowedRoles) ? allowedRoles : [allowedRoles];

  return function RoleProtectedComponent(props) {
    const { user, loading } = useAuth();
    const router = useRouter();

    useEffect(() => {
      if (!loading && typeof user !== "undefined") {
        if (!user) {
          router.replace("/login");
          return;
        }
        
        // Check role
        if (!allowed.includes(user.role)) {
          router.replace("/unauthorized");
          return;
        }
        
        // Check specific permissions
        for (const permission of requiredPermissions) {
          if (!user[permission]) {
            router.replace("/unauthorized");
            return;
          }
        }
      }
    }, [user, loading, router]);

    if (loading || typeof user === "undefined") {
      return <div>Loading...</div>;
    }

    if (!user || !allowed.includes(user.role)) {
      return null;
    }

    // Check permissions
    for (const permission of requiredPermissions) {
      if (!user[permission]) {
        return null;
      }
    }

    return <Component {...props} />;
  };
};


////////////////////////////////////////////


// Mobile-optimized waiter dashboard
import { useState, useEffect } from 'react';
import { useAuth } from '@/context/AuthContext';
import withRoleGuard from '@/hoc/withRoleGuard';
import Link from 'next/link';

function WaiterDashboard() {
  const { user, logout } = useAuth();
  const [myOrders, setMyOrders] = useState([]);
  const [tables, setTables] = useState([]);

  useEffect(() => {
    fetchMyOrders();
    fetchTables();
  }, []);

  const fetchMyOrders = async () => {
    try {
      const res = await fetch('/api/tables/orders/waiter_orders/', {
        headers: { Authorization: `Bearer ${user?.access}` }
      });
      if (res.ok) setMyOrders(await res.json());
    } catch (error) {
      console.error('Error fetching orders:', error);
    }
  };

  const fetchTables = async () => {
    try {
      const res = await fetch('/api/tables/tables/?status=available', {
        headers: { Authorization: `Bearer ${user?.access}` }
      });
      if (res.ok) setTables(await res.json());
    } catch (error) {
      console.error('Error fetching tables:', error);
    }
  };

  return (
    <div className="min-h-screen bg-blue-50 p-4">
      <div className="max-w-sm mx-auto">
        {/* Header */}
        <div className="bg-white rounded-lg p-4 mb-4 shadow">
          <div className="flex justify-between items-center">
            <h1 className="text-xl font-bold">ߑ Hello Waiter!</h1>
            <button onClick={logout} className="text-red-600 text-sm">Logout</button>
          </div>
          <p className="text-gray-600 text-sm">{user?.email}</p>
        </div>

        {/* Quick Actions */}
        <div className="grid grid-cols-2 gap-3 mb-6">
          <Link 
            href="/waiter/create-order"
            className="bg-green-600 text-white p-6 rounded-lg text-center shadow hover:bg-green-700"
          >
            <div className="text-3xl mb-2">➕</div>
            <div className="font-bold">New Order</div>
          </Link>
          
          <Link 
            href="/waiter/my-orders"
            className="bg-blue-600 text-white p-6 rounded-lg text-center shadow hover:bg-blue-700"
          >
            <div className="text-3xl mb-2">ߓ</div>
            <div className="font-bold">My Orders</div>
          </Link>
        </div>

        {/* Available Tables */}
        <div className="bg-white rounded-lg p-4 mb-4 shadow">
          <h3 className="font-bold mb-3">Available Tables ({tables.length})</h3>
          <div className="grid grid-cols-3 gap-2">
            {tables.slice(0, 9).map(table => (
              <Link
                key={table.id}
                href={`/waiter/create-order?table=${table.id}`}
                className="bg-green-100 border-2 border-green-300 p-3 rounded text-center hover:bg-green-200"
              >
                <div className="font-bold">T{table.table_number}</div>
                <div className="text-xs text-gray-600">{table.capacity} seats</div>
              </Link>
            ))}
          </div>
        </div>

        {/* Recent Orders */}
        <div className="bg-white rounded-lg p-4 shadow">
          <h3 className="font-bold mb-3">My Recent Orders</h3>
          {myOrders.slice(0, 3).map(order => (
            <div key={order.id} className="border-b pb-2 mb-2 last:border-b-0">
              <div className="flex justify-between">
                <span className="font-medium">Table {order.table_number}</span>
                <span className={`text-sm px-2 py-1 rounded ${
                  order.status === 'pending' ? 'bg-yellow-100 text-yellow-800' :
                  order.status === 'completed' ? 'bg-green-100 text-green-800' :
                  'bg-blue-100 text-blue-800'
                }`}>
                  {order.status}
                </span>
              </div>
              <div className="text-sm text-gray-600">
                {order.items_count} items • ₹{order.total_amount}
              </div>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}

export default withRoleGuard(WaiterDashboard, ['waiter'], ['can_create_orders']);


/////////////////////////////////////////////////


# Navigate to backend
cd ~/hotel-management-backend

# Backup current database
python manage.py dumpdata > backup_$(date +%Y%m%d_%H%M%S).json


/////////////////////////////////////////

# EXACT REPLACEMENT for CustomUser class
class CustomUser(AbstractBaseUser, PermissionsMixin):
    ROLE_CHOICES = (
        ('admin', 'Admin'),
        ('staff', 'Staff'),
        ('waiter', 'Waiter'),     # NEW
        ('biller', 'Biller'),     # NEW
    )

    email = models.EmailField(unique=True)
    role = models.CharField(max_length=10, choices=ROLE_CHOICES)  # INCREASED from 10
    is_active = models.BooleanField(default=True)
    is_staff = models.BooleanField(default=False)
    
    # NEW PERMISSION FIELDS
    can_create_orders = models.BooleanField(default=False)
    can_generate_bills = models.BooleanField(default=False)
    can_access_kitchen = models.BooleanField(default=False)

    USERNAME_FIELD = 'email'
    REQUIRED_FIELDS = []
    objects = CustomUserManager()

    def save(self, *args, **kwargs):
        # Auto-assign permissions based on role
        if self.role == 'admin':
            self.can_create_orders = True
            self.can_generate_bills = True
            self.can_access_kitchen = True
        elif self.role == 'waiter':
            self.can_generate_bills = False
            self.can_access_kitchen = False
        elif self.role == 'biller':
            self.can_create_orders = False
            self.can_access_kitchen = False
        
        super().save(*args, **kwargs)

    def __str__(self):
        return self.email


////////////////////////////////////////


# Create migration for new fields
python manage.py makemigrations users --name add_waiter_biller_roles

# Review migration before applying
python manage.py sqlmigrate users 0002  # Check SQL

# Apply migration  
python manage.py migrate users
